<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Rules · inspectIT Ocelot Documentation</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Rules define (a) how data should be extracted when the instrumented"/><meta name="docsearch:version" content="0.4"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Rules · inspectIT Ocelot Documentation"/><meta property="og:type" content="website"/><meta property="og:url" content="https://inspectit.github.io/inspectit-ocelot/"/><meta property="og:description" content="Rules define (a) how data should be extracted when the instrumented"/><meta property="og:image" content="https://inspectit.github.io/inspectit-ocelot/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://inspectit.github.io/inspectit-ocelot/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/inspectit-ocelot/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/inspectit-ocelot/js/scrollSpy.js"></script><link rel="stylesheet" href="/inspectit-ocelot/css/main.css"/><script src="/inspectit-ocelot/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/inspectit-ocelot/"><img class="logo" src="/inspectit-ocelot/img/ocelot_head_sil_logo.svg" alt="inspectIT Ocelot Documentation"/><h2 class="headerTitleWithLogo">inspectIT Ocelot Documentation</h2></a><a href="/inspectit-ocelot/versions"><h3>0.4</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="https://inspectit.rocks/" target="_self">inspectIT Ocelot Website</a></li><li class=""><a href="https://github.com/inspectIT/inspectit-ocelot" target="_self">GitHub Repository</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Instrumentation</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Getting Started<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/doc1">Hello World</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/getting-started/quick-start">Quick Start</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/getting-started/docker-examples">Demo Application</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/getting-started/installation">Installation</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Configuration<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/configuration/configuration-sources">Configuration Sources</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/configuration/external-configuration-sources">External Configuration Sources</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/configuration/logging-configuration">Logging Configuration</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/configuration/open-census-configuration">OpenCensus Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Metrics<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/metrics/metrics">Metrics</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/metrics/metric-recorders">Metrics Recorders</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/metrics/metric-exporters">Metrics Exporters</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/metrics/common-tags">Common Tags</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/metrics/custom-metrics">Custom Metrics</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/metrics/self-monitoring">Self-Monitoring</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Tracing<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/tracing/tracing">Tracing</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/tracing/trace-exporters">Trace Exporters</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Instrumentation<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/instrumentation/instrumentation">Instrumentation</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/instrumentation/scopes">Scopes</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/inspectit-ocelot/docs/0.4/instrumentation/rules">Rules</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/instrumentation/special-sensors">Special Sensors</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/instrumentation/process">Instrumentation Process</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">End User Monitoring<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/enduser-monitoring/enduser-monitoring-server">EUM Server</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Configuration Server<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/config-server/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/config-server/agent-mappings">Agent Mappings</a></li><li class="navListItem"><a class="navItem" href="/inspectit-ocelot/docs/0.4/config-server/user-authentication">User Authentication</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/inspectIT/inspectit-ocelot/edit/master/inspectit-ocelot-documentation/docs/instrumentation/rules.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Rules</h1></header><article><div><span><p>Rules define (a) how data should be extracted when the instrumented
method is executed and (b) which metrics shall be recorded.
The selection on which methods these actions are applied is done through <a href="/inspectit-ocelot/docs/0.4/instrumentation/scopes">scopes</a>.</p>
<p>A highlight of inspectIT is the fact that you are completely free in defining how the data is
extracted. In addition, the extracted data can be made visible outside of the instrumented method
in which it was collected: Data can be configured to be propagated up or down with the call stack,
which is explained in the section <a href="#data-propagation">Data Propagation</a>.</p>
<p>The overall concept of rules is best explained with a simple example which is part of the inspectIT Ocelot default configuration:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">rules:</span>

      <span class="hljs-attr">record_method_duration:</span>

        <span class="hljs-attr">entry:</span>
          <span class="hljs-attr">method_entry_time:</span>
            <span class="hljs-attr">action:</span> <span class="hljs-string">timestamp_nanos</span>
          <span class="hljs-attr">method_name:</span>
            <span class="hljs-attr">action:</span> <span class="hljs-string">get_method_fqn</span>

        <span class="hljs-attr">exit:</span>
          <span class="hljs-attr">method_duration:</span>
            <span class="hljs-attr">action:</span> <span class="hljs-string">elapsed_millis</span>
            <span class="hljs-attr">data-input:</span>
              <span class="hljs-attr">sinceNanos:</span> <span class="hljs-string">method_entry_time</span>

        <span class="hljs-attr">metrics:</span>
          <span class="hljs-string">'[method/duration]'</span> <span class="hljs-string">:</span> <span class="hljs-string">method_duration</span>
</code></pre>
<p>This example rule named <code>record_method_duration</code> measures the duration of the instrumented method and outputs the value using the <code>method/duration</code> metric.</p>
<p>As the name states, we define under the <code>entry</code> property of the rule which actions are performed on method entry. Similarly, the <code>exit</code> property defines what is done when the instrumented method returns. In both sections we collect data.</p>
<p>On entry, we collect the current timestamp in a variable named <code>method_entry_time</code> and the name of the currently executed method in <code>method_name</code>.
These variables are <em>data</em>, their names are referred to as <em>data keys</em>. Note that we also define how the data is collected: For <code>method_entry_time</code> we invoke the <a href="#actions">action</a> named <code>timestamp_nanos</code> and for <code>method_name</code> the one named <code>get_method_fqn</code>.</p>
<p>This data is then used on method exit: using the action <code>elapsed_millis</code> we compute the time which has passed since <code>method_entry_time</code>. Finally, the duration computed this way is used as value for the <code>method/duration</code> metric. As shown in the <a href="/inspectit-ocelot/docs/0.4/metrics/custom-metrics">definition</a> of this metric, the collected <code>method_name</code> is used as tag for all of its views.</p>
<h2><a class="anchor" aria-hidden="true" id="data-propagation"></a><a href="#data-propagation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Data Propagation</h2>
<p>As illustrated by the previous example, we can collect any amount of data in both the entry and the exit section of an instrumented method. Each data is hereby identified by its name, the <em>data key</em>.
Internally, inspectIT creates a dictionary like Object each time an instrumented method is executed. This object is basically a local variable for the method. Whenever data is written, inspectIT stores the value under the given data key in this dictionary. Similarly, whenever data is read, inspectIT looks it up based on the data key in the dictionary. This dictionary is called <em>inspectIT context</em>.</p>
<p>If the inspectIT context was truly implemented as explained above, all data would be only visible in the method where it was collected. This however often is not the desired behaviour.
Consider the following example: you instrument the entry method of your HTTP server and collect the request URL as data there. You now of course want this data to be visible as tag for metrics collected in methods called by your entry point. With the implementation above, the request URL would only be visible within the HTTP entry method.</p>
<p>For this reason the inspectIT context implements <em>data propagation</em>. The propagation can happen in two directions:</p>
<ul>
<li><strong>Down Propagation:</strong> Data collected in your instrumented method will also be visible to all methods directly or indirectly called by your method. This behaviour already comes <a href="https://opencensus.io/tag/#propagation">with the OpenCensus Library for tags</a>.</li>
<li><strong>Up Propagation:</strong> Data collected in your instrumented method will be visible to the methods which caused the invocation of your method. This means that all methods which lie on the call stack will have access to the data written by your method</li>
</ul>
<p>Up- and down propagation can also be combined: in this case then the data is attached to the control flow, meaning that it will appear as if its value will be passed around with every method call and return.</p>
<p>The second aspect of propagation to consider is the <em>level</em>. Does the propagation happen within each Thread separately or is it propagated across threads? Also, what about propagation across JVM boarders, e.g. one micro service calling another one via HTTP? In inspectIT Ocelot we provide the following two settings for the propagation level.</p>
<ul>
<li><strong>JVM local:</strong> The data is propagated within the JVM, even across thread boarders. The behaviour when data moves from one thread to another is defined through <a href="/inspectit-ocelot/docs/0.4/instrumentation/special-sensors">Special Sensors</a>.</li>
<li><strong>Global:</strong> Data is propagated within the JVM and even across JVM boarders. For example, when an application issues an HTTP request, the globally down propagated data is added to the headers of the request. When the response arrives, up propagated data is collected from the response headers. Again, this protocol specific behaviour is realized through <a href="/inspectit-ocelot/docs/0.4/instrumentation/special-sensors">Special Sensors</a>.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="defining-the-behaviour"></a><a href="#defining-the-behaviour" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining the Behaviour</h3>
<p>The propagation behaviour is not defined on rule level but instead globally based on the data keys under the configuration
property <code>inspectit.instrumentation.data</code>. Here are some examples extracted from the default configurations of inspectIT:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">data:</span>
      <span class="hljs-comment"># for correlating calls across JVM boarders</span>
      <span class="hljs-attr">prop_origin_service:</span> <span class="hljs-string">{down-propagation:</span> <span class="hljs-string">GLOBAL,</span> <span class="hljs-attr">is-tag:</span> <span class="hljs-literal">false</span><span class="hljs-string">}</span>
      <span class="hljs-attr">prop_target_service:</span> <span class="hljs-string">{up-propagation:</span> <span class="hljs-string">GLOBAL,</span> <span class="hljs-attr">down-propagation:</span> <span class="hljs-string">JVM_LOCAL,</span> <span class="hljs-attr">is-tag:</span> <span class="hljs-literal">false</span><span class="hljs-string">}</span>

      <span class="hljs-comment">#we allow the application to be defined at the beginning and to be down propagated from there</span>
      <span class="hljs-attr">application:</span> <span class="hljs-string">{down-propagation:</span> <span class="hljs-string">GLOBAL,</span> <span class="hljs-attr">is-tag:</span> <span class="hljs-literal">true</span><span class="hljs-string">}</span>

      <span class="hljs-comment">#this data will only be visible locally in the method where it is collected</span>
      <span class="hljs-attr">http_method:</span> <span class="hljs-string">{down-propagation:</span> <span class="hljs-string">NONE}</span>
      <span class="hljs-attr">http_status:</span> <span class="hljs-string">{down-propagation:</span> <span class="hljs-string">NONE}</span>
</code></pre>
<p>Under <code>inspectit.instrumentation.data</code>, the data keys are mapped to their desired behaviour.
The configuration options are the following:</p>
<table>
<thead>
<tr><th>Config Property</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>down-propagation</code></td><td><code>JVM_LOCAL</code></td><td>Configures if values for this data key propagate down and the level of propagation.</td></tr>
</tbody>
</table>
<p>Possible values are <code>NONE</code>, <code>JVM_LOCAL</code> and <code>GLOBAL</code>. If <code>NONE</code> is configured, no down propagation will take place.
|<code>up-propagation</code>|<code>NONE</code>| Configures if values for this data key propagate up and the level of propagation.
Possible values are <code>NONE</code>, <code>JVM_LOCAL</code> and <code>GLOBAL</code>. If <code>NONE</code> is configured, no up propagation will take place.
|<code>is-tag</code>|<code>true</code>|If true, this data will act as a tag when metrics are recorded. This does not influence propagation, e.g. typically you want tags to be down propagated JVM locally.</p>
<p>Note that you are free to use data keys without explicitly defining them in the <code>inspectit.instrumentation.data</code> section. In this case simply all settings are assumed to be default, which corresponds to the behaviour of OpenCensus tags.</p>
<h3><a class="anchor" aria-hidden="true" id="interaction-with-opencensus-tags"></a><a href="#interaction-with-opencensus-tags" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interaction with OpenCensus Tags</h3>
<p>As explained previously, our inspectIT context can be seen as a more flexible variation of OpenCensus tags. In fact, we designed the inspectIT context so that it acts as a superset of the OpenCensus TagContext.</p>
<p>Firstly, when an instrumented method is entered, a new inspectIT context is created. At this point, it imports any tag values published by OpenCensus directly as data. This also includes the <a href="/inspectit-ocelot/docs/0.4/metrics/common-tags">common tags</a> created by inspectIT. This means, that you can simply read (and overwrite) values for common tags such as <code>service</code> or <code>host_address</code> at any rule.</p>
<p>The integration is even deeper if you <a href="/inspectit-ocelot/docs/0.4/configuration/open-census-configuration">configured the agent to also extract the metrics from manual instrumentation in your application</a>.
Firstly, if a method instrumented by inspectIT Ocelot is executed within a TagContext opened by your application,
these application tags will also be visible in the inspectIT context. Secondly, after the execution of the entry phase of each rule, a new TagContext is opened making the tags written there accessible to metrics collected by your application. Hereby, only data for which down propagation was configured to be <code>JVM_LOCAL</code> or greater and for which <code>is-tag</code> is true will be visible as tags.</p>
<h2><a class="anchor" aria-hidden="true" id="actions"></a><a href="#actions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Actions</h2>
<p>Actions are the tool for extracting arbitrary data from your application or the context.
They are effectively Lambda-like functions you can invoke from the entry and the exit phase of rules. They are defined by (a) specifying their input parameters and (b) giving a Java code snippet which defines how the result value is computed from these.</p>
<p>Again, this is best explained by giving some simple examples extracted from inspectIT Ocelot default configuration:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">actions:</span>

      <span class="hljs-comment">#computes a nanosecond-timestamp as a long for the current point in time</span>
      <span class="hljs-attr">timestamp_nanos:</span>
        <span class="hljs-attr">value:</span> <span class="hljs-string">"new Long(System.nanoTime())"</span>

      <span class="hljs-comment">#computes the elapsed milliseconds as double since a given nanosecond-timestamp</span>
      <span class="hljs-attr">elapsed_millis:</span>
        <span class="hljs-attr">input:</span>
          <span class="hljs-comment">#the timestamp captured via System.nanoTime() to compare against</span>
          <span class="hljs-attr">sinceNanos:</span> <span class="hljs-string">long</span>
        <span class="hljs-attr">value:</span> <span class="hljs-string">"new Double( (System.nanoTime() - sinceNanos) * 1E-6)"</span>

      <span class="hljs-attr">string_replace_all:</span>
        <span class="hljs-attr">input:</span>
          <span class="hljs-attr">regex:</span> <span class="hljs-string">String</span>
          <span class="hljs-attr">replacement:</span> <span class="hljs-string">String</span>
          <span class="hljs-attr">string:</span> <span class="hljs-string">String</span>
        <span class="hljs-attr">value:</span> <span class="hljs-string">"string.replaceAll(regex,replacement)"</span>

      <span class="hljs-attr">get_method_fqn:</span>
        <span class="hljs-attr">input:</span>
          <span class="hljs-attr">_methodName:</span> <span class="hljs-string">String</span>
          <span class="hljs-attr">_class:</span> <span class="hljs-string">Class</span>
        <span class="hljs-attr">value:</span> <span class="hljs-string">"new StringBuilder(_class.getName()).append('.').append(_methodName).toString()"</span>
</code></pre>
<p>The names of the first two actions, <code>timestamp_nanos</code> and <code>elapsed_millis</code> should be familiar for you from the initial example in the <a href="/inspectit-ocelot/docs/0.4/instrumentation/rules">rules section</a>.</p>
<p>The code executed when a action is invoked is defined through the <code>value</code> configuration property. In YAML, this is simply a string. InspectIT however will interpret this string as a Java expression to evaluate. The result value of this expression will be used as result for the action invocation.</p>
<p>Note that the code will not be interpreted at runtime, but instead inspectIT Ocelot will compile the expression to bytecode to ensure maximum efficiency. As indicated by the manual primitive boxing performed for <code>timestamp_nanos</code> the compiler has some restrictions. For example Autoboxing is not supported. However, actions are expected to return Objects, therefore manual boxing has to be performed. Under the hood, inspectIT uses the <a href="http://www.javassist.org/">javassist</a> library, where all imposed restrictions can be found.
The most important ones are that neither Autoboxing, Generics, Anonymous Classes or Lambda Expressions are supported.</p>
<p>After actions have been compiled, they are placed in the same class loader as the class you instrument with them. This means that they can access any class that your application class could also access.</p>
<blockquote>
<p>Even if your action terminates with an exception or error, inspectIT will make sure that this does not affect your application. InspectIT will print information about the error and the faulting action. The execution of the action in the rule where the failure occured will be disabled until you update your configuration.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="input-parameters"></a><a href="#input-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Input Parameters</h3>
<p>As previously mentioned actions are also free to define any kind of <em>input parameters</em> they need. This is done using the <code>input</code> configuration property.
This property maps the names of the input parameters to their expected Java type.
For example, the <code>elapsed_millis</code> action declares a single input variable named <code>sinceNanos</code> which has the type <code>long</code>. Note that for input parameters automatic primitive unboxing is supported.</p>
<p>Another example where the action even defines multiple inputs is <code>string_replace_all</code>. Guess what this action does? <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replaceAll-java.lang.String-java.lang.String">Hint</a>.</p>
<p>The fourth example shown above is <code>get_method_fqn</code>, which uses the <em>special</em> input parameters <code>_methodName</code> and <code>_class</code>. The fact that these variables are special is indicated by the leading underscore. When normally invoking actions from rules, the user has to take care that all input parameters are assigned a value. For special input parameters inspectIT automatically assigned the desired value. This means that for example <code>get_method_fqn</code> can be called without manually assigning any parameter, like it was done in the initial example in the <a href="/inspectit-ocelot/docs/0.4/instrumentation/rules">rules section</a>. An overview of all available special input parameters is given below:</p>
<table>
<thead>
<tr><th>Parameter Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>_methodName</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String</a></td><td>The name of the instrumented method within which this action is getting executed.</td></tr>
<tr><td><code>_class</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html">Class</a></td><td>The class declaring the instrumented method within which this action is getting executed.</td></tr>
<tr><td><code>_parameterTypes</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html">Class</a>[]</td><td>The types of the parameters which the instrumented method declares for which the action is executed.</td></tr>
<tr><td><code>_this</code></td><td>(depends on context)</td><td>The this-instance in the context of the instrumented method within which this action is getting executed.</td></tr>
<tr><td><code>_args</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">Object</a>[]</td><td>The arguments with which the instrumented method was called within which this action is getting executed. The arguments are boxed if necessary and packed into an array.</td></tr>
<tr><td><code>_arg0,_arg1,...,_argN</code></td><td>(depends on context)</td><td>The N-th argument with which the instrumented method was called within which this action is getting executed.</td></tr>
<tr><td><code>_returnValue</code></td><td>(depends on context)</td><td>The value returned by the instrumented method within which this action is getting executed. If the method terminated with an exception or the action is executed in the entry phase this is <code>null</code>.</td></tr>
<tr><td><code>_thrown</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html">Throwable</a></td><td>The exception thrown by the instrumented method within which this action is getting executed. If the method returned normally or the action is executed in the entry phase this is <code>null</code>.</td></tr>
<tr><td><code>_context</code></td><td><a href="https://github.com/inspectIT/inspectit-ocelot/blob/master/inspectit-ocelot-bootstrap/src/main/java/rocks/inspectit/ocelot/bootstrap/exposed/InspectitContext.java">InspectitContext</a></td><td>Gives direct read and write access to the current <a href="#data-propagation">context</a>. Can be used to implement custom data propagation.</td></tr>
<tr><td><code>_attachments</code></td><td><a href="https://github.com/inspectIT/inspectit-ocelot/blob/master/inspectit-ocelot-bootstrap/src/main/java/rocks/inspectit/ocelot/bootstrap/exposed/ObjectAttachments.java">ObjectAttachments</a></td><td>Allows you to attach values to objects instead of to the control flow, as done via <code>_context</code>.</td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="multiple-statements-and-imports"></a><a href="#multiple-statements-and-imports" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multiple statements and Imports</h3>
<p>Actions can easily become more complex, so that a single expression is not sufficient for expressing the functionality.
For this purpose we introduced the <code>value-body</code> configuration property for actions as an alternative to <code>value</code>.
<code>value-body</code> allows you to specify a Java method body which returns the result of the action. The body is given without surrounding curly braces. One example action from the default configuration making use of this is given below:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">actions:</span>
      <span class="hljs-attr">get_servlet_request_path:</span>
        <span class="hljs-attr">imports:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">javax.servlet</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">javax.servlet.http</span>
        <span class="hljs-attr">input:</span>
          <span class="hljs-attr">_arg0:</span> <span class="hljs-string">ServletRequest</span>
        <span class="hljs-attr">value-body:</span> <span class="hljs-string">|
          if(_arg0 instanceof HttpServletRequest) {
            return java.net.URI.create(((HttpServletRequest)_arg0).getRequestURI()).getPath();
          }
          return null;
</span></code></pre>
<p>This action is designed to be applied on the Servlet API <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain">doFilter</a> and
<a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/Servlet.html#service-javax.servlet.ServletRequest-javax.servlet.ServletResponse">service</a> methods.
It's purpose is to extract HTTP path, however in the servlet API it is not guaranteed that the <code>ServletRequest</code> is a <code>HttpServletRequest</code>.
For this reason the action performs an instance-of check only returning the HTTP path if it is available, otherwise <code>null</code>.</p>
<p>Normally, all non <code>java.lang.*</code> types have to be referred to using their fully qualified name, as done for <code>java.net.URI</code> in the example above. However, just like in Java you can import packages using the <code>import</code> config option. In this example this allows us to refer to <code>ServletRequest</code> and <code>HttpServletRequest</code> without using the fully qualified name.</p>
<h2><a class="anchor" aria-hidden="true" id="defining-rules"></a><a href="#defining-rules" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining Rules</h2>
<p>Rules glue together <a href="/inspectit-ocelot/docs/0.4/instrumentation/scopes">scopes</a> and <a href="/inspectit-ocelot/docs/0.4/instrumentation/rules#actions">actions</a> to define which actions you want to perform on which application methods.</p>
<p>As you might have noticed, the initial example rule shown in the <a href="/inspectit-ocelot/docs/0.4/instrumentation/rules">rules section</a> did not define any reference to a scope. This is because this rule originates form the default configuration of inspectIT Ocelot, where we don't know yet of which methods you want to collect the response time. Therefore this rule is defined without scopes, but you can easily add some in your own configuration files:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">rules:</span>

      <span class="hljs-attr">record_method_duration:</span>
        <span class="hljs-attr">scopes:</span>
          <span class="hljs-attr">my_first_scope:</span> <span class="hljs-literal">true</span>
          <span class="hljs-attr">my_second_scope:</span> <span class="hljs-literal">true</span>
</code></pre>
<p>With this snippet we defined that the existing rule <code>record_method_duration</code> gets applied on the two scopes named <code>my_first_scope</code> and <code>my_second_scope</code>. The <code>scopes</code> configuration option maps scope names to <code>true</code> or <code>false</code>. The rule will be applied on all methods matching any scope where the value is <code>true</code>.</p>
<p>Rules define their action within three <em>phases</em>:</p>
<ul>
<li><p><strong>Entry Phase:</strong> The actions defined in this phase get invoked directly before the body of the instrumented method. You can imagine that these actions are &quot;inlined&quot; at the very top of every method instrumented by the given rule.</p></li>
<li><p><strong>Exit Phase:</strong> The actions defined in this phase get invoked after the body of the instrumented method has terminated. This can be the method either returning normally or throwing an exception. You can imagine that these actions are placed in a <code>finally</code> block of a <code>try</code> block surrounding the body of the instrumented method.</p></li>
<li><p><strong>Metrics Phase:</strong> These actions are executed directly after the <em>exit phase</em>.
Here, only values for metrics are recorded. No actions will be executed here.</p></li>
</ul>
<p>The actions performed in this phases are defined in rules under the <code>entry</code>, <code>exit</code> and <code>metrics</code> configuration options. In the entry and in the exit phase the actions you perform are invocations of <a href="#actions">actions</a>. Please see the <a href="#invoking-actions">Invoking Actions</a> section for information on how this is done.</p>
<p>In the <em>metrics phase</em> you only can collect metrics, this is explained in the <a href="#collecting-metrics">Collecting Metrics</a> section.</p>
<h3><a class="anchor" aria-hidden="true" id="invoking-actions"></a><a href="#invoking-actions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invoking Actions</h3>
<p>In this section you will find out how to collect data in the entry and exit phase of rules by invoking <a href="#actions">actions</a> and storing the results in the <a href="#data-propagation">inspectIT context</a>.</p>
<p>Let's take a look again at the entry phase definitions of the <code>record_method_duration</code> rule:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-comment">#inspectit.instrumentation.rules is omitted here</span>
<span class="hljs-attr">record_method_duration:</span>
  <span class="hljs-attr">entry:</span>
    <span class="hljs-attr">method_entry_time:</span>
      <span class="hljs-attr">action:</span> <span class="hljs-string">timestamp_nanos</span>
    <span class="hljs-attr">method_name:</span>
      <span class="hljs-attr">action:</span> <span class="hljs-string">get_method_fqn</span>
</code></pre>
<p>The <code>entry</code> and <code>exit</code> configuration options are YAML dictionaries mapping data keys to <em>action invocations</em>.
This means the keys used in the dictionaries define the data key for which a value is being defined. Correspondingly, the assigned value defines which action is invoked to define the value of the data key.</p>
<p>In the example above <code>method_entry_time</code> is a data key. The action which is invoked is defined through the <code>action</code> configuration option. In this case, it is the action named <code>timestamp_nanos</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="assigning-input-parameter-values"></a><a href="#assigning-input-parameter-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Assigning Input Parameter Values</h4>
<p>Actions <a href="#input-parameters">can require input parameters</a> which need to be assigned when invoking them.
There are currently two possible ways of doing this:</p>
<ul>
<li><strong>Assigning Data Values:</strong> In this case, the value for a given data key is extracted from the <a href="#data-propagation">inspectIT context</a> and passed to the action</li>
<li><strong>Assigning Constant Values:</strong> In this case a literal specified in the configuration will directly be passed to the action.</li>
</ul>
<p>We have already seen how the assignment of data values to parameters is done in the exit phase of the <code>record_method_duration</code> rule:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-comment">#inspectit.instrumentation.rules is omitted here</span>
<span class="hljs-attr">record_method_duration:</span>
  <span class="hljs-attr">exit:</span>
    <span class="hljs-attr">method_duration:</span>
      <span class="hljs-attr">action:</span> <span class="hljs-string">elapsed_millis</span>
      <span class="hljs-attr">data-input:</span>
        <span class="hljs-attr">sinceNanos:</span> <span class="hljs-string">method_entry_time</span>
</code></pre>
<p>The <code>elapsed_millis</code> action requires a value for the input parameter <code>sinceNanos</code>.
In this example we defined that the value for the data key <code>method_entry_time</code> is used for <code>sinceNanos</code>.</p>
<p>The assignment of constant values works very similar:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-comment">#inspectit.instrumentation.rules is omitted here</span>
<span class="hljs-attr">example_rule:</span>
  <span class="hljs-attr">entry:</span>
    <span class="hljs-attr">hello_world_text:</span>
      <span class="hljs-attr">action:</span> <span class="hljs-string">set</span>
      <span class="hljs-attr">constant-input:</span>
        <span class="hljs-attr">value:</span> <span class="hljs-string">"Hello World!"</span>
</code></pre>
<p>Note that when assigning a constant value, inspectIT Ocelot automatically converts the given value to the type expected by the action. This is done using the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/ConversionService.html">Spring Conversion Service</a>. For example, if your action expects a parameter of type <code>java.time.Duration</code>, you can simply pass in <code>&quot;42s&quot;</code> as constant.</p>
<p>As you might have noticed, <code>data-input</code> and <code>constant-input</code> are again YAML dictionaries.
This allows you to assign values for actions which expect multiple input parameters.
You can also mix which parameters you assign from data and which from constants:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-comment">#inspectit.instrumentation.rules is omitted here</span>
<span class="hljs-attr">example_rule:</span>
  <span class="hljs-attr">entry:</span>
    <span class="hljs-attr">bye_world_text:</span>
      <span class="hljs-attr">action:</span> <span class="hljs-string">string_replace_all</span>
      <span class="hljs-attr">data-input:</span>
        <span class="hljs-attr">string:</span> <span class="hljs-string">hello_world_text</span>
      <span class="hljs-attr">constant-input:</span>
        <span class="hljs-attr">regex:</span> <span class="hljs-string">"Hello"</span>
        <span class="hljs-attr">replacement:</span> <span class="hljs-string">"Bye"</span>
</code></pre>
<p>As expected given the <a href="#actions">definition</a> of the <code>string_replace_all</code> action, the value of <code>bye_world_text</code> will be <code>&quot;Bye World!&quot;</code></p>
<h4><a class="anchor" aria-hidden="true" id="adding-conditions"></a><a href="#adding-conditions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding Conditions</h4>
<p>It is possible to add conditions to action invocations. The invocation will only occur if the specified condition is met. Currently, the following configuration options can be used:</p>
<table>
<thead>
<tr><th>Config Option</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>only-if-null</code></td><td>Only executes the invocation if the value assigned with the given data key is null.</td></tr>
<tr><td><code>only-if-not-null</code></td><td>Only executes the invocation if the value assigned with the given data key is not null.</td></tr>
<tr><td><code>only-if-true</code></td><td>Only executes the invocation if the value assigned with the given data key is the boolean value <code>true</code>.</td></tr>
<tr><td><code>only-if-false</code></td><td>Only executes the invocation if the value assigned with the given data key is the boolean value <code>false</code>.</td></tr>
</tbody>
</table>
<p>An example for the usage of a condition is given below:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-comment">#inspectit.instrumentation.rules is omitted here</span>
<span class="hljs-attr">example_rule:</span>
  <span class="hljs-attr">entry:</span>
    <span class="hljs-attr">application_name:</span>
      <span class="hljs-attr">action:</span> <span class="hljs-string">set</span>
      <span class="hljs-attr">constant-input:</span>
        <span class="hljs-attr">value:</span> <span class="hljs-string">"My-Application"</span>
    <span class="hljs-attr">only-if-null:</span> <span class="hljs-string">application_name</span>
</code></pre>
<p>In this example we define an invocation to set the value of the data key <code>application_name</code>
to <code>&quot;My-Application&quot;</code>. However, this assignment is only performed if <code>application_name</code> previously was null, meaning that no value has been assigned yet. This mechanism is in particular useful when <code>application_name</code> is <a href="#data-propagation">down propagated</a>.</p>
<p>If multiple conditions are given for the same action invocation, the invocation is only executed if <em>all</em> conditions are met.</p>
<h4><a class="anchor" aria-hidden="true" id="execution-order"></a><a href="#execution-order" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Execution Order</h4>
<p>As we can use data values for input parameters and for conditions, action invocations can depend on another. This means that a defined order on action executions within each phase is required for rules to work as expected.</p>
<p>As all invocations are specified under the <code>entry</code> or the <code>exit</code> config options which are YAML dictionaries, the order they are given in the config file does not matter. YAML dictionaries do not maintain or define an order of their entries.</p>
<p>However, inspectIT Ocelot <em>automatically</em> orders the invocations for you correctly.
For each instrumented method the agent first finds all rules which have scopes matching the given method. Afterwards, these rules get combined into one &quot;super&quot;-rule by simply merging the <code>entry</code>, <code>exit</code> and <code>metrics</code> phases.</p>
<p>Within the <code>entry</code> and the <code>exit</code> phase, actions are now automatically ordered based on their dependencies. E.g. if the invocation writing <code>data_b</code> uses <code>data_a</code> as input, the invocation writing <code>data_a</code> is guaranteed to be executed first! Whenever you use a data value as value for a parameter or in a condition, this will be counted as a dependency.</p>
<p>In some rare cases you might want to change this behaviour. E.g. in tracing context you want to store the <a href="#data-propagation">down propagated</a> <code>span_id</code> in <code>parent_span</code>, before the current method assigns a new <code>span_id</code>. This can easily be realized using the <code>before</code> config option for action invocations:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-comment">#inspectit.instrumentation.rules is omitted here</span>
<span class="hljs-attr">example_rule:</span>
  <span class="hljs-attr">entry:</span>
    <span class="hljs-attr">parent_span:</span>
      <span class="hljs-attr">action:</span> <span class="hljs-string">set</span>
      <span class="hljs-attr">data-input:</span>
        <span class="hljs-attr">value:</span> <span class="hljs-string">span_id</span>
    <span class="hljs-attr">before:</span>
      <span class="hljs-attr">span_id:</span> <span class="hljs-literal">true</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="collecting-metrics"></a><a href="#collecting-metrics" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Collecting Metrics</h3>
<p>Metrics collection is done in the metrics phase of a rule, which can be configured using the <code>metrics</code> option:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-comment">#inspectit.instrumentation.rules is omitted here</span>
<span class="hljs-attr">example_rule:</span>
  <span class="hljs-comment">#...</span>
  <span class="hljs-attr">exit:</span>
    <span class="hljs-attr">method_duration:</span>
      <span class="hljs-comment">#action invocation here....</span>

  <span class="hljs-attr">metrics:</span>
    <span class="hljs-string">'[method/duration]'</span> <span class="hljs-string">:</span> <span class="hljs-string">method_duration</span>
    <span class="hljs-string">'[some/other/metric]'</span> <span class="hljs-string">:</span> <span class="hljs-number">42</span>
</code></pre>
<p>The metrics phase is executed after the exit phase of the rule. As shown above, you can simply assign values to metrics based on their name. You must however have <a href="/inspectit-ocelot/docs/0.4/metrics/custom-metrics">defined the metric</a> to use them.</p>
<p>The measurement value written to the metric can be specified by giving a data key. This was done in the example above for <code>method/duration</code>: Here, the value for the data key <code>method_duration</code> is taken, which we previously wrote in the exit phase.
Alternatively you can just specify a constant which will be used, like it was done for <code>some/other/metric</code>.</p>
<p>If the value assigned with the data key you specified is <code>null</code> (e.g. no data was collected), no value for the metric will be written out.</p>
<p>In addition, all configured tags for the metrics will also be taken from the inspectIT context, if they have been <a href="#defining-the-behaviour">configured to be used as tags</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="collecting-traces"></a><a href="#collecting-traces" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Collecting Traces</h3>
<p>The inspectIT Ocelot agent allows you to record method invocations as <a href="https://opencensus.io/tracing/span/">OpenCensus spans</a>.
In order to make your collected spans visible, you must first set up a <a href="/inspectit-ocelot/docs/0.4/tracing/trace-exporters">trace exporter</a>.</p>
<p>Afterwards you can define that all methods matching a certain rule will be traced:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">rules:</span>
      <span class="hljs-attr">example_rule:</span>
        <span class="hljs-attr">tracing:</span>
          <span class="hljs-attr">start-span:</span> <span class="hljs-literal">true</span>
</code></pre>
<p>For example, using the previous configuration snippet, each method that matches the scope definition of the <code>example_rule</code> rule will appear within a trace. Its appearance can be customized using the following properties which can be set in the rule's <code>tracing</code> section.</p>
<table>
<thead>
<tr><th>Property</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>start-span</code></td><td><code>false</code></td><td>If true, all method invocations of methods matching any scope of this rule will be collected as spans.</td></tr>
<tr><td><code>name</code></td><td><code>null</code></td><td>Defines a data key whose value will be used as name for the span. If it is <code>null</code> or the value for the data key is <code>null</code>, the full qualified name of the method will be used. Note that the value for the data key must be written in the entry section of the rule at latest!</td></tr>
<tr><td><code>kind</code></td><td><code>null</code></td><td>Can be <code>null</code>, <code>CLIENT</code> or <code>SERVER</code> corresponding to the <a href="https://opencensus.io/tracing/span/kind/">OpenCensus values</a>.</td></tr>
<tr><td><code>attributes</code></td><td><code>{}</code> (empty dictionary)</td><td>Maps names of attributes to data keys whose values will be used on exit to populate the given attributes.</td></tr>
</tbody>
</table>
<p>Commonly, you do not want to have the full qualified name of the instrumented method as span name. For example, for HTTP requests you typically want the HTTP path as span name. This behaviour can be customized using the <code>name</code> property:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">rules:</span>
      <span class="hljs-attr">servlet_api_service:</span>
        <span class="hljs-attr">tracing:</span>
          <span class="hljs-attr">start-span:</span> <span class="hljs-literal">true</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">http_path</span>
        <span class="hljs-attr">entry:</span>
          <span class="hljs-attr">http_path:</span>
           <span class="hljs-comment">#... action call to fetch the http path here</span>
</code></pre>
<blockquote>
<p>The name must exist at the end of the entry section and cannot be set in the exit section.</p>
</blockquote>
<p>It is often desirable to not capture every trace, but instead <a href="https://opencensus.io/tracing/sampling/">sample</a> only a subset.
This can be configured using the <code>sample-probability</code> setting under the <code>tracing</code> section:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">rules:</span>
      <span class="hljs-attr">servlet_api_service:</span>
        <span class="hljs-attr">tracing:</span>
          <span class="hljs-attr">start-span:</span> <span class="hljs-literal">true</span>
          <span class="hljs-attr">sample-probability:</span> <span class="hljs-number">0.2</span>
</code></pre>
<p>The example shown above will ensure that only 20% of all traces starting at the given rule will actually be exported.
Instead of specifying a fixed value, you can also specify a data key here, just like for <code>name</code>.
In this case, the value from the given data key is read and used as sampling probability.
This allows you for example to vary the sample probability based on the HTTP url.</p>
<p>If no sample probability is defined for a rule, the <a href="/inspectit-ocelot/docs/0.4/tracing/tracing">default probability</a> is used.</p>
<p>Another useful property of spans is that you can attach any additional information in form of attributes.
In most tracing backends such as ZipKin and Jaeger, you can search your traces based on attributes.
The example below shows how you can define attributes:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">rules:</span>
      <span class="hljs-attr">servlet_api_service:</span>
        <span class="hljs-attr">tracing:</span>
          <span class="hljs-attr">attributes:</span>
            <span class="hljs-attr">http_host:</span> <span class="hljs-string">host_name</span>
        <span class="hljs-attr">entry:</span>
          <span class="hljs-attr">host_name:</span>
           <span class="hljs-comment">#... action call to fetch the http host here</span>
</code></pre>
<p>The attributes property maps the names of attributes to data keys.
After the rule's exit phase, the corresponding data keys are read and attached as attributes to the current span.</p>
<p>Note that a rule does not have to start a span for attatching attributes.
If a rule does not start a span, the attributes will be written to the first span opened by any method on the current call stack.</p>
<p>It is also possible to conditionalize the span starting as well as the attribute writing:</p>
<pre><code class="hljs css language-yaml"><span class="hljs-attr">inspectit:</span>
  <span class="hljs-attr">instrumentation:</span>
    <span class="hljs-attr">rules:</span>
      <span class="hljs-attr">span_starting_rule:</span>
        <span class="hljs-attr">tracing:</span>
          <span class="hljs-attr">start-span:</span> <span class="hljs-literal">true</span>
          <span class="hljs-attr">start-span-conditions:</span>
            <span class="hljs-attr">only-if-true:</span> <span class="hljs-string">my_condition_data</span>
<span class="hljs-comment">#....</span>
      <span class="hljs-attr">attribute_writing_rule:</span>
        <span class="hljs-attr">tracing:</span>
          <span class="hljs-attr">attributes:</span>
            <span class="hljs-attr">attrA:</span> <span class="hljs-string">data_a</span>
            <span class="hljs-attr">attrB:</span> <span class="hljs-string">data_b</span>
          <span class="hljs-attr">attribute-conditions:</span>
            <span class="hljs-attr">only-if-true:</span> <span class="hljs-string">my_condition_data</span>
</code></pre>
<p>If any <code>start-span-conditions</code> are defined, a span will only be created when all conditions are met.
Analogous to this, attributes will only be written if each condition defined in <code>attribute-conditions</code> is fulfilled.
The conditions that can be defined are equal to the ones of actions, thus, please see the <a href="#adding-conditions">action conditions description</a> for detailed information.</p>
<p>With the previous shown settings, it is possible to add an instrumentation which creates exactly one span per invocation of an instrumented method. Especially in asynchronous scenarios, this might not be the desired behaviour:
For these cases inspectIT Ocelot offers the possibility to record multiple method invocations into a single span.
The resulting span then has the following properties:</p>
<ul>
<li>the span starts with the first invoked method and ends as soon as the last one returns</li>
<li>all attributes written by each method are combined into the single span</li>
<li>all invocations made from the methods which compose the single span will appear as children of this span</li>
</ul>
<p>This can be configured by defining for rules that they (a) can continue existing spans and (b) can optionally end the span they started or continued.</p>
<p>Firstly, it is possible to &quot;remember&quot; the span created or continued using the <code>store-span</code> option:</p>
<pre><code class="hljs css language-yaml">    <span class="hljs-attr">rules:</span>
      <span class="hljs-attr">span_starting_rule:</span>
        <span class="hljs-attr">tracing:</span>
          <span class="hljs-attr">start-span:</span> <span class="hljs-literal">true</span>
          <span class="hljs-attr">store-span:</span> <span class="hljs-string">my_span_data</span>
          <span class="hljs-attr">end-span:</span> <span class="hljs-literal">false</span>
</code></pre>
<p>With this option, the span created at the end of the entry phase will be stored in the context with the data key <code>my_span_data</code>. Usually this span reference is then extracted from the context and attached ot an object via the <a href="#input-parameters">_attachments</a>.</p>
<p>Without the <code>end-span: false</code> definition above, the span would be ended as soon as the instrumented method returns.
By setting <code>end-span</code> to false, the span is kept open instead. It can then be continued when another method is executed as follows:</p>
<pre><code class="hljs css language-yaml">    <span class="hljs-attr">rules:</span>
      <span class="hljs-attr">span_finishing_rule:</span>
        <span class="hljs-attr">tracing:</span>
          <span class="hljs-attr">continue-span:</span> <span class="hljs-string">my_span_data</span>
          <span class="hljs-attr">end-span:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># actually not necessary as it is the default value</span>
</code></pre>
<p>Methods instrumented with this rule will not create a new span. Instead at the end of the entry phase the data for the key <code>my_span_data</code> is read from the context. If it contains a valid span written via <code>store-span</code>, this span is continued in this method. This implies that all spans started by callees of this method will appear as children of the span stored in <code>my_span_data</code>. In addition, this rule also then causes the continued span to end with the execution of the method due to the <code>end-span</code> option. This is not required to happen: a span can be continued by any number of rules before it is finally ended.</p>
<p>It also is possible to define rules for which both <code>start-span</code> and <code>continue-span</code> is configured.
In this case, the rule will first attempt to continue the existing span. Only if this fails (e.g. because the specified span does not exist yet or the conditions are not met) a new span is started.</p>
<p>Again, conditions for the span continuing and span ending can be specified just like for the span starting.
The properties <code>continue-span-conditions</code> and <code>end-span-conditions</code> work just like <code>start-span-conditions</code>.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2/28/2024 by NTTechnicalUser</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/inspectit-ocelot/docs/0.4/instrumentation/scopes"><span class="arrow-prev">← </span><span>Scopes</span></a><a class="docs-next button" href="/inspectit-ocelot/docs/0.4/instrumentation/special-sensors"><span>Special Sensors</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#data-propagation">Data Propagation</a><ul class="toc-headings"><li><a href="#defining-the-behaviour">Defining the Behaviour</a></li><li><a href="#interaction-with-opencensus-tags">Interaction with OpenCensus Tags</a></li></ul></li><li><a href="#actions">Actions</a><ul class="toc-headings"><li><a href="#input-parameters">Input Parameters</a></li><li><a href="#multiple-statements-and-imports">Multiple statements and Imports</a></li></ul></li><li><a href="#defining-rules">Defining Rules</a><ul class="toc-headings"><li><a href="#invoking-actions">Invoking Actions</a></li><li><a href="#collecting-metrics">Collecting Metrics</a></li><li><a href="#collecting-traces">Collecting Traces</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2024 Novatec Consulting GmbH</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'P7JV0ZK66K',
                apiKey: 'd499024131bf8d92e6d469a6c14f4798',
                indexName: 'inspectit-ocelot',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["version:0.4"]}
              });
            </script></body></html>