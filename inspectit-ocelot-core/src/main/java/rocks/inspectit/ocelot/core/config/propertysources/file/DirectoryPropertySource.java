package rocks.inspectit.ocelot.core.config.propertysources.file;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.env.EnumerablePropertySource;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.AbstractResource;
import org.springframework.core.io.FileSystemResource;
import rocks.inspectit.ocelot.core.config.util.PropertyUtils;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Stream;

/**
 * Special Properties source which adds all .properties, .json and .yml/.yaml files from a directory and its subdirectories as property sources.
 * The files are parsed in alphabetical order where the configuration from the first found file wins.
 * This is done by adding the DirectoryPropertySource as marker which is followed by all contained files as PropertySources.
 * {@link org.springframework.core.env.CompositePropertySource} was not used as this causes issues with the overwriting of Lists.
 *
 * @author Jonas Kunz
 */
@Slf4j
public class DirectoryPropertySource extends EnumerablePropertySource<Void> {

    private static final List<String> JSON_ENDINGS = Arrays.asList(".json");

    private static final List<String> PROPERTIES_ENDINGS = Arrays.asList(".properties");

    private static final List<String> YAML_ENDINGS = Arrays.asList(".yml", ".yaml");

    @FunctionalInterface
    private interface PropertiesLoader {

        Properties load(AbstractResource res) throws Exception;
    }

    @Getter
    private Path rootDir;

    /**
     * Creates a new DirectoryPropertySource.
     * It has to be added to a container manually and then {@link #reload(MutablePropertySources)} has to called to load the actual configurations.
     *
     * @param name    the name of this source
     * @param rootDir the root directory to parse
     */
    public DirectoryPropertySource(String name, Path rootDir) {
        super(name);
        this.rootDir = rootDir;
    }

    /**
     * Removes all previously loaded {@link PropertySource}s generated by this {@link DirectoryPropertySource} in the given container.
     * Afterwards parses the directory and generated a {@link PropertySource} for each found config file, which is added
     * after this {@link DirectoryPropertySource} to the container.
     *
     * @param container the container to update
     */
    public void reload(MutablePropertySources container) {
        removeChildrenFromContainer(container);

        List<ChildFilePropertySource> childSources = loadContentsToPropertySources();

        PropertySource<?> previous = this;
        for (ChildFilePropertySource childSource : childSources) {
            container.addAfter(previous.getName(), childSource);
            previous = childSource;
        }
    }

    private void removeChildrenFromContainer(MutablePropertySources container) {
        container.stream()
                .filter(ps -> ps instanceof ChildFilePropertySource)
                .map(ps -> (ChildFilePropertySource) ps)
                .filter(ps -> ps.getOwner() == this)
                .map(PropertySource::getName)
                .forEach(container::remove);
    }

    private List<ChildFilePropertySource> loadContentsToPropertySources() {
        try (Stream<Path> files = Files.walk(rootDir).filter(p -> !p.toFile().isDirectory())) {
            // alphabetical order, FIRST loaded file wins
            List<ChildFilePropertySource> fileSources = new ArrayList<>();
            files.sorted(Comparator.comparing(Path::toString, String.CASE_INSENSITIVE_ORDER)).forEachOrdered(file -> {
                if (doesFileHaveEnding(file, PROPERTIES_ENDINGS)) {
                    loadProperties(file, PropertyUtils::readPropertyFiles).ifPresent(fileSources::add);
                } else if (doesFileHaveEnding(file, YAML_ENDINGS)) {
                    loadProperties(file, PropertyUtils::readYamlFiles).ifPresent(fileSources::add);
                } else if (doesFileHaveEnding(file, JSON_ENDINGS)) {
                    loadProperties(file, PropertyUtils::readJsonFile).ifPresent(fileSources::add);
                }
            });
            return fileSources;
        } catch (Exception e) {
            logger.error("Unable to access config directory.", e);
            return Collections.emptyList();
        }
    }

    private Optional<ChildFilePropertySource> loadProperties(Path file, PropertiesLoader loader) {
        try {
            String name = getCombinedName(file);
            return Optional.of(new ChildFilePropertySource(name, loader.load(new FileSystemResource(file))));
        } catch (Exception e) {
            logger.error("Unable to load config file " + getRelativePath(file) + "!", e);
            return Optional.empty();
        }
    }

    private static boolean doesFileHaveEnding(Path path, Collection<String> allowedEndings) {
        String filename = path.getFileName().toString().toLowerCase();
        return allowedEndings.stream().anyMatch(ending -> filename.endsWith(ending));
    }

    private String getRelativePath(Path file) {
        return rootDir.relativize(file).toString().replace(File.separator, "/");
    }

    private String getCombinedName(Path file) {
        return getName() + "/" + getRelativePath(file);
    }

    @Override
    public String[] getPropertyNames() {
        return new String[0];
    }

    @Override
    public Object getProperty(String name) {
        return null;
    }

    /**
     * Nested class representing a single loaded configuration file
     */
    private class ChildFilePropertySource extends PropertiesPropertySource {

        public ChildFilePropertySource(String name, Properties source) {
            super(name, source);
        }

        /**
         * @return the {@link DirectoryPropertySource} to which this file belongs
         */
        DirectoryPropertySource getOwner() {
            return DirectoryPropertySource.this;
        }
    }
}
