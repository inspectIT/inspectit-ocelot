package rocks.inspectit.ocelot.core.config.propertysources.file;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.springframework.core.env.EnumerablePropertySource;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.AbstractResource;
import org.springframework.core.io.FileSystemResource;
import rocks.inspectit.ocelot.core.config.util.PropertyUtils;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Stream;

/**
 * Special Properties source which adds all .properties, .json and .yml/.yaml files from a directory and its subdirectories as property sources.
 * The files are parsed in alphabetical order where the configuration from the first found file wins.
 * This is done by adding the DirectoryPropertySource as marker which is followed by all contained files as PropertySources.
 * {@link org.springframework.core.env.CompositePropertySource} was not used as this causes issues with the overwriting of Lists.
 *
 * @author Jonas Kunz
 */
@Slf4j
public class DirectoryPropertySource extends EnumerablePropertySource<Void> {


    private static final List<String> JSON_ENDINGS = Arrays.asList(".json");
    private static final List<String> PROPERTIES_ENDINGS = Arrays.asList(".properties");
    private static final List<String> YAML_ENDINGS = Arrays.asList(".yml", ".yaml");

    @FunctionalInterface
    private interface PropertiesLoader {
        Properties load(AbstractResource res) throws Exception;
    }

    @Getter
    private Path rootDir;

    /**
     * Creates a new DirectoryPropertySource.
     * It has to be added to a container manually and then {@link #reload(MutablePropertySources)} has to called to load the actual configurations.
     *
     * @param name    the name of this source
     * @param rootDir the root directory to parse
     */
    public DirectoryPropertySource(String name, Path rootDir) {
        super(name);
        this.rootDir = rootDir;
    }

    /**
     * Removes all previously loaded {@link PropertySource}s generated by this {@link DirectoryPropertySource} in the given container.
     * Afterwards parses the directory and generated a {@link PropertySource} for each found config file, which is added after this {@link DirectoryPropertySource} to the container.
     *
     * @param container the container to update
     */
    public void reload(MutablePropertySources container) {
        removeChildrenFromContainer(container);

        List<ChildFilePropertySource> childSources = loadContentsToPropertySources();

        PropertySource<?> previous = this;
        for (val pps : childSources) {
            container.addAfter(previous.getName(), pps);
            previous = pps;
        }
    }

    private void removeChildrenFromContainer(MutablePropertySources container) {
        container.stream()
                .filter(ps -> ps instanceof ChildFilePropertySource)
                .map(ps -> (ChildFilePropertySource) ps)
                .filter(ps -> ps.getOwner() == this)
                .map(PropertySource::getName)
                .forEach(container::remove);
    }

    private List<ChildFilePropertySource> loadContentsToPropertySources() {
        Stream<Path> files = null;
        List<ChildFilePropertySource> fileSources = Collections.emptyList();
        try {
            files = Files.walk(rootDir).filter(p -> !p.toFile().isDirectory());
        //alphabetical order, last loaded file wins
        List<ChildFilePropertySource> tempList = new ArrayList<>();
        files.sorted(Comparator.comparing(Path::toString, String.CASE_INSENSITIVE_ORDER))
                .forEachOrdered(file -> {
                    if (doesFileHaveEnding(file, PROPERTIES_ENDINGS)) {
                        loadProperties(file, PropertyUtils::readPropertyFiles).ifPresent(tempList::add);
                    } else if (doesFileHaveEnding(file, YAML_ENDINGS)) {
                        loadProperties(file, PropertyUtils::readYamlFiles).ifPresent(tempList::add);
                    } else if (doesFileHaveEnding(file, JSON_ENDINGS)) {
                        loadProperties(file, PropertyUtils::readJsonFile).ifPresent(tempList::add);
                    }
                });
        fileSources = tempList; // all or nothing
        } catch (IOException e) {
            logger.error("Unable to access config dir", e);
        } finally {
            if (files != null) {
                try {
                    files.close();
                } catch (Exception e2) {
                    logger.error("Error closing file stream", e2);
                }
            }
        }

        return fileSources;
    }

    private Optional<ChildFilePropertySource> loadProperties(Path file, PropertiesLoader loader) {
        try {
            String name = getCombinedName(file);
            return Optional.of(new ChildFilePropertySource(name, loader.load(new FileSystemResource(file))));
        } catch (Exception e) {
            logger.error("Unable to load config file " + getRelativePath(file) + "!", e);
            return Optional.empty();
        }
    }


    private static boolean doesFileHaveEnding(Path path, Collection<String> allowedEndings) {
        String filename = path.getFileName().toString().toLowerCase();
        return allowedEndings.stream().anyMatch(ending -> filename.endsWith(ending));
    }

    private String getRelativePath(Path file) {
        return rootDir.relativize(file)
                .toString()
                .replace(File.separator, "/");
    }

    private String getCombinedName(Path file) {
        return getName() + "/" + getRelativePath(file);
    }


    @Override
    public String[] getPropertyNames() {
        return new String[0];
    }

    @Override
    public Object getProperty(String name) {
        return null;
    }

    /**
     * Nested class representing a single loaded configuration file
     */
    private class ChildFilePropertySource extends PropertiesPropertySource {

        public ChildFilePropertySource(String name, Properties source) {
            super(name, source);
        }

        /**
         * @return the {@link DirectoryPropertySource} to which this file belongs
         */
        DirectoryPropertySource getOwner() {
            return DirectoryPropertySource.this;
        }
    }
}
