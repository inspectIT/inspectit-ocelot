package rocks.inspectit.ocelot.core.instrumentation.autotracing;

import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanKind;
import io.opentelemetry.context.Context;
import io.opentelemetry.sdk.common.Clock;
import io.opentelemetry.sdk.trace.AnchoredClockUtils;
import io.opentelemetry.sdk.trace.OcelotSpanUtils;
import lombok.Setter;
import rocks.inspectit.ocelot.core.utils.OpenTelemetryUtils;

import java.util.concurrent.TimeUnit;

/**
 * Allows building of spans with custom timestamps.
 */
public class CustomSpanBuilder {

    /**
     * The span to use as parent.
     */
    private Span parent;

    /**
     * The name to use for the span.
     */
    private String name;

    /**
     * The spanId to use, null if it should be autogenerated.
     */
    private String spanId;

    /**
     * The {@link AnchoredClock} (known as timestamp converter in OpenCensus) to use for the overridden timestamp {@link #entryNanos} and {@link #exitNanos}.
     */
    private Object anchoredClock;

    /**
     * The span kind to assign to the span.
     */
    private SpanKind kind;

    /**
     * The timestamps to use for the new span. If not set, the span takes times as usual.
     */
    private long entryNanos = 0;

    private long exitNanos = 0;

    /**
     * The {@link Attributes attributes} to be added to the span
     */
    private Attributes attributes;

    private CustomSpanBuilder(String name, Span parent) {
        this.parent = parent;
        this.name = name;
    }

    public static CustomSpanBuilder builder(String name, Span parent) {
        return new CustomSpanBuilder(name, parent);
    }

    /**
     * Replaces the timings on the resulting Span.
     * An {@link io.opentelemetry.sdk.trace.AnchoredClock} (known as timestamp converter in OpenCensus) must be given if the parent is not a sampled span, otherwise it can be null.
     *
     * @param entryNanos    the nano entry timestamp
     * @param exitNanos     the nano exit timestamp
     * @param anchoredClock the anchored clock (timestamp converter) to use, if null it will be derived from the parent span.
     *
     * @return the builder
     */
    public CustomSpanBuilder customTiming(long entryNanos, long exitNanos, Object anchoredClock) {
        if (anchoredClock == null) {
            if (parent.isRecording()) {
                this.anchoredClock = OcelotSpanUtils.getAnchoredClock(parent);
            } else {
                throw new IllegalArgumentException("converter may only be null if the parent is a SdkSpan");
            }
        } else {
            if (!AnchoredClockUtils.isInstance(anchoredClock)) {
                throw new IllegalArgumentException("expected AnchoredClock but received {} " + anchoredClock.getClass()
                        .getName());
            }
            this.anchoredClock = anchoredClock;
        }
        this.entryNanos = entryNanos;
        this.exitNanos = exitNanos;
        return this;
    }

    public CustomSpanBuilder spanId(String id) {
        spanId = id;
        return this;
    }

    public CustomSpanBuilder kind(SpanKind kind) {
        this.kind = kind;
        return this;
    }

    public CustomSpanBuilder attributes(Attributes attributes) {
        this.attributes = attributes;
        return this;
    }

    public Span startSpan() {
        if (entryNanos != 0) {

            DummyAnchoredClock clock = DummyAnchoredClock.create(anchoredClock);
            clock.setNanoTime(entryNanos);

            Span result = OpenTelemetryUtils.getTracer()
                    .spanBuilder(name)
                    .setSpanKind(kind)
                    .setParent(Context.current().with(parent))
                    .setStartTimestamp(clock.now(), TimeUnit.NANOSECONDS)
                    .setAllAttributes(attributes)
                    .startSpan();
            // override spanId if applicable
            if (null != spanId) {
                OcelotSpanUtils.setSpanId(result, spanId);
            }
            clock.setNanoTime(exitNanos);

            // set the Span's AnchoredClock via reflection.
            OcelotSpanUtils.setAnchoredClock(result, AnchoredClockUtils.create(clock, clock.epochNanos, clock.startNanoTime));
            return result;
        } else {
            return OpenTelemetryUtils.getTracer()
                    .spanBuilder(name)
                    .setSpanKind(kind)
                    .setParent(Context.current().with(parent))
                    .startSpan();
        }
    }

    /**
     * A dummy {@link io.opentelemetry.sdk.trace.AnchoredClock} that returns fixed values for {@link #now()} and {@link #nanoTime}
     */
    private static class DummyAnchoredClock implements Clock {

        /**
         * Reference nano time
         */
        @Setter
        private long startNanoTime;

        /**
         * Current nano time
         */
        @Setter
        private long nanoTime;

        /**
         * The start time in epoch nanos.
         */
        @Setter
        private long epochNanos;

        @Override
        public long now() {
            return epochNanos + (nanoTime - startNanoTime);
        }

        @Override
        public long nanoTime() {
            return nanoTime;
        }

        /**
         * Creates a new {@link DummyAnchoredClock} with {@link #epochNanos} and {@link #startNanoTime} derived from the {@link AnchoredClock anchoredClock}
         *
         * @param anchoredClock
         *
         * @return
         */
        static DummyAnchoredClock create(Object anchoredClock) {
            DummyAnchoredClock clock = new DummyAnchoredClock(AnchoredClockUtils.getStartTime(anchoredClock), AnchoredClockUtils.getNanoTime(anchoredClock));
            return clock;
        }

        DummyAnchoredClock() {

        }

        DummyAnchoredClock(long epochNanos, long startNanoTime) {
            this.epochNanos = epochNanos;
            this.startNanoTime = startNanoTime;
            nanoTime = startNanoTime;
        }

    }
}
