package rocks.inspectit.ocelot.core.instrumentation.autotracing;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanKind;
import io.opentelemetry.context.Context;
import io.opentelemetry.sdk.common.Clock;
import io.opentelemetry.sdk.trace.OcelotSpanUtils;
import lombok.Setter;
import rocks.inspectit.ocelot.core.utils.OpenTelemetryUtils;

import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * Allows building of spans with custom timestamps.
 */
public class CustomSpanBuilder {

    private final static Class<?> ANCHOREDCLOCK_CLASS;

    /**
     * Random used to generate span IDs.
     */
    private static final Random RANDOM = new Random();

    /**
     * The span to use as parent.
     */
    private Span parent;

    /**
     * The name to use for the span.
     */
    private String name;

    /**
     * The spanId to use, null if it should be autogenerated.
     */
    private String spanId;

    /**
     * The {@link AnchoredClock} (known as timestamp converter in OpenCensus) to use for the overriden timestamp {@link #entryNanos} and {@link #exitNanos}.
     */
    private Object anchoredClock;

    /**
     * The span kind to assign to the span.
     */
    private SpanKind kind;

    /**
     * The timestamps to use for the new span. If not set, the span takes times as usual.
     */
    private long entryNanos = 0;

    private long exitNanos = 0;

    static {
        try {
            ANCHOREDCLOCK_CLASS = Class.forName("io.opentelemetry.sdk.trace.AnchoredClock");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private CustomSpanBuilder(String name, Span parent) {
        this.parent = parent;
        this.name = name;
    }

    public static CustomSpanBuilder builder(String name, Span parent) {
        return new CustomSpanBuilder(name, parent);
    }

    /**
     * Replaces the timings on the resulting Span.
     * An {@link io.opentelemetry.sdk.trace.AnchoredClock} (known as timestamp converter in OpenCensus) must be given if the parent is not a sampled span, otherwise it can be null.
     *
     * @param entryNanos    the nano entry timestamp
     * @param exitNanos     the nano exit timestamp
     * @param anchoredClock the anchored clock (timestamp converter) to use, if null it will be derived from the parent span.
     *
     * @return the builder
     */
    public CustomSpanBuilder customTiming(long entryNanos, long exitNanos, Object anchoredClock) {
        if (anchoredClock == null) {
            if (parent.isRecording()) {
                this.anchoredClock = OcelotSpanUtils.getAnchoredClock(parent);
            } else {
                throw new IllegalArgumentException("converter may only be null if the parent is a SdkSpan");
            }
        } else {
            if (!ANCHOREDCLOCK_CLASS.isInstance(anchoredClock)) {
                throw new IllegalArgumentException("expected AnchoredClock but received {} " + anchoredClock.getClass()
                        .getName());
            }
            this.anchoredClock = anchoredClock;
        }
        this.entryNanos = entryNanos;
        this.exitNanos = exitNanos;
        return this;
    }

    public CustomSpanBuilder spanId(String id) {
        spanId = id;
        return this;
    }

    public CustomSpanBuilder kind(SpanKind kind) {
        this.kind = kind;
        return this;
    }

    public Span startSpan() {
        if (entryNanos != 0) {
            DummyClock clock = new DummyClock();
            clock.setValue(entryNanos);

            Span result = OpenTelemetryUtils.getTracer()
                    .spanBuilder(name)
                    .setSpanKind(kind)
                    .setParent(Context.current().with(parent))
                    .setStartTimestamp(entryNanos, TimeUnit.NANOSECONDS)
                    .startSpan();
            clock.setValue(exitNanos);
            // set the AnchoredClock via reflection.
            OcelotSpanUtils.setAnchoredClock(result, OcelotSpanUtils.createAnchoredClock(clock));
            return result;
        } else {
            return OpenTelemetryUtils.getTracer()
                    .spanBuilder(name)
                    .setSpanKind(kind)
                    .setParent(Context.current().with(parent))
                    .startSpan();
        }
    }

    private static class DummyClock implements Clock {

        @Setter
        private long value;

        @Override
        public long now() {
            return value;
        }

        @Override
        public long nanoTime() {
            return 0;
        }
    }
}
